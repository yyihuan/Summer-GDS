# Summer-GDS åœ†å½¢æ”¯æŒæŠ€æœ¯æ–¹æ¡ˆ

## ğŸ¯ æ–¹æ¡ˆæ¦‚è¿°

åŸºäºéœ€æ±‚åˆ†æå’Œç°æœ‰ç³»ç»Ÿæ¶æ„ï¼Œæˆ‘ä»¬é‡‡ç”¨**æ¸è¿›å¼å®ç°æ–¹æ¡ˆ**ï¼šé¦–å…ˆå¿«é€Ÿå®ç°åŸºç¡€åŠŸèƒ½éªŒè¯ç”¨æˆ·éœ€æ±‚ï¼Œç„¶åé€æ­¥å¢å¼ºåŠŸèƒ½æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### æ ¸å¿ƒç­–ç•¥
- **UIæ–¹æ¡ˆC**ï¼šä¸‹æ‹‰é€‰æ‹© + åŠ¨æ€è¡¨å•
- **æ•°æ®ç­–ç•¥**ï¼šç­–ç•¥1ï¼ˆå‰ç«¯ç”Ÿæˆï¼‰â†’ ç­–ç•¥3ï¼ˆå…ƒæ•°æ®ä¿å­˜ï¼‰

## ğŸ“‹ æ–¹æ¡ˆå¯¹æ¯”åˆ†æ

### UIäº¤äº’è®¾è®¡æ–¹æ¡ˆ

#### æ–¹æ¡ˆAï¼šå¼¹å‡ºå¡ç‰‡å¼
```
[é¡¶ç‚¹è¾“å…¥æ¡†] [ğŸ”§ å½¢çŠ¶ç”Ÿæˆå™¨]
                â†“ ç‚¹å‡»å¼¹å‡º
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ å½¢çŠ¶ç±»å‹: [åœ†å½¢ â–¼]    â”‚
        â”‚ åœ†å¿ƒX: [____]       â”‚
        â”‚ åœ†å¿ƒY: [____]       â”‚
        â”‚ åŠå¾„:  [____]       â”‚
        â”‚ ç²¾åº¦:  [____]       â”‚
        â”‚ [ç”Ÿæˆ] [å–æ¶ˆ]        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¼˜ç‚¹**ï¼šä¸å½±å“ç°æœ‰ç•Œé¢å¸ƒå±€ï¼Œæ‰©å±•æ€§å¥½
**ç¼ºç‚¹**ï¼šéœ€è¦é¢å¤–ç‚¹å‡»æ­¥éª¤ï¼Œå¼¹çª—å¯èƒ½å½±å“ç”¨æˆ·ä½“éªŒ

#### æ–¹æ¡ˆBï¼šåˆ‡æ¢æ ‡ç­¾å¼
```
[é¡¶ç‚¹å®šä¹‰] [åœ†å½¢] [çŸ©å½¢] [æ¤­åœ†]...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å½“å‰é€‰ä¸­"åœ†å½¢"æ—¶æ˜¾ç¤ºï¼š
åœ†å¿ƒX: [____]  åœ†å¿ƒY: [____]
åŠå¾„:  [____]  ç²¾åº¦:  [____]
```

**ä¼˜ç‚¹**ï¼šæ‰€è§å³æ‰€å¾—ï¼Œåˆ‡æ¢ä¾¿æ·
**ç¼ºç‚¹**ï¼šå ç”¨æ›´å¤šå‚ç›´ç©ºé—´ï¼Œå½¢çŠ¶ç±»å‹å¤šæ—¶æ ‡ç­¾æ‹¥æŒ¤

#### æ–¹æ¡ˆCï¼šä¸‹æ‹‰é€‰æ‹© + åŠ¨æ€è¡¨å•ï¼ˆæ¨èï¼‰
```
å®šä¹‰æ–¹å¼: [é¡¶ç‚¹åæ ‡ â–¼]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å½“é€‰æ‹©"åœ†å½¢"æ—¶ï¼Œä¸‹æ–¹åŠ¨æ€æ˜¾ç¤ºï¼š
åœ†å¿ƒX: [____]  åœ†å¿ƒY: [____]
åŠå¾„:  [____]  ç²¾åº¦:  [____]
```

**ä¼˜ç‚¹**ï¼šç•Œé¢ç®€æ´ï¼Œç©ºé—´åˆ©ç”¨é«˜æ•ˆï¼Œæ“ä½œç›´è§‚
**ç¼ºç‚¹**ï¼šåŠ¨æ€è¡¨å•æœ‰è½»å¾®åˆ‡æ¢å»¶è¿Ÿï¼ˆå¯å¿½ç•¥ï¼‰

### æ•°æ®å¤„ç†ç­–ç•¥æ–¹æ¡ˆ

#### ç­–ç•¥1ï¼šå‰ç«¯ç”Ÿæˆé¡¶ç‚¹ + YAMLå…¼å®¹ï¼ˆé˜¶æ®µä¸€ï¼‰
```javascript
// å‰ç«¯å¤„ç†
function generateCircleVertices(centerX, centerY, radius, segments = 64) {
    const vertices = [];
    for (let i = 0; i < segments; i++) {
        const angle = (2 * Math.PI * i) / segments;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        vertices.push(`${x.toFixed(3)},${y.toFixed(3)}`);
    }
    return vertices.join(':');
}

// æœ€ç»ˆYAMLé…ç½®
vertices: "0,10:9.8,3.1:..."  // å‰ç«¯ç”Ÿæˆçš„åœ†å½¢é¡¶ç‚¹
```

**ä¼˜ç‚¹**ï¼š
- åç«¯å®Œå…¨æ— éœ€ä¿®æ”¹ï¼Œå…¼å®¹æ€§æœ€ä½³
- YAMLé…ç½®ç®€æ´ï¼ŒåªåŒ…å«é¡¶ç‚¹ä¿¡æ¯
- å¿«é€Ÿå®ç°ï¼ŒéªŒè¯éœ€æ±‚

**ç¼ºç‚¹**ï¼š
- åœ†å½¢ä¿¡æ¯ä¸¢å¤±ï¼Œæ— æ³•åå‘ç¼–è¾‘
- ç²¾åº¦å›ºå®šåæ— æ³•è°ƒæ•´

#### ç­–ç•¥2ï¼šYAMLæ‰©å±•æ ¼å¼ + åç«¯å¤„ç†
```yaml
shapes:
  - type: "polygon"
    geometry:
      type: "circle"
      center: [10, 10]
      radius: 5
      segments: 64
    layer: [1, 0]
```

**ä¼˜ç‚¹**ï¼šä¿ç•™å®Œæ•´åœ†å½¢ä¿¡æ¯ï¼Œé…ç½®è¯­ä¹‰åŒ–
**ç¼ºç‚¹**ï¼šéœ€è¦å¤§å¹…ä¿®æ”¹åç«¯ï¼Œå¼€å‘å·¥ä½œé‡å¤§

#### ç­–ç•¥3ï¼šæ··åˆæ ¼å¼ + å…ƒæ•°æ®ä¿ç•™ï¼ˆé˜¶æ®µäºŒï¼‰
```yaml
shapes:
  - type: "polygon"
    vertices: "0,10:9.8,3.1:..."  # ç”Ÿæˆçš„é¡¶ç‚¹
    _metadata:  # å…ƒæ•°æ®ï¼Œç”¨äºå‰ç«¯åå‘ç¼–è¾‘
      source: "circle"
      params:
        center_x: 0
        center_y: 0
        radius: 10
        segments: 64
    layer: [1, 0]
```

**ä¼˜ç‚¹**ï¼š
- åç«¯å…¼å®¹æ€§å¥½ï¼Œåªéœ€å¿½ç•¥_metadata
- å‰ç«¯å¯ä»¥åå‘ç¼–è¾‘
- ä¿ç•™äº†ç”Ÿæˆä¿¡æ¯

**ç¼ºç‚¹**ï¼šé…ç½®æ–‡ä»¶ç¨æ˜¾å†—ä½™

## ğŸ¯ æ¨èæ–¹æ¡ˆï¼šæ¸è¿›å¼å®ç°

### é˜¶æ®µä¸€ï¼šå¿«é€ŸéªŒè¯ï¼ˆUIæ–¹æ¡ˆC + ç­–ç•¥1ï¼‰

#### å®ç°ç›®æ ‡
- éªŒè¯UIäº¤äº’è®¾è®¡çš„åˆç†æ€§
- å¿«é€Ÿå“åº”ç”¨æˆ·éœ€æ±‚
- æœ€å°åŒ–å¼€å‘é£é™©

#### æŠ€æœ¯å®ç°
1. **HTMLæ¨¡æ¿æ”¹é€ **
   ```html
   <!-- åœ¨ç°æœ‰é¡¶ç‚¹è¾“å…¥åŒºåŸŸä¸Šæ–¹æ·»åŠ  -->
   <div class="row">
       <div class="col-md-6 mb-3">
           <label for="geometryType" class="form-label">å®šä¹‰æ–¹å¼</label>
           <select class="form-select geometry-type-select" name="shapes[{index}].geometry_type">
               <option value="vertices">é¡¶ç‚¹åæ ‡</option>
               <option value="circle">åœ†å½¢</option>
           </select>
       </div>
   </div>

   <!-- åœ†å½¢å‚æ•°åŒºåŸŸï¼ˆé»˜è®¤éšè—ï¼‰ -->
   <div class="circle-params-container" style="display: none;">
       <div class="row">
           <div class="col-md-3 mb-3">
               <label class="form-label">åœ†å¿ƒX (Î¼m)</label>
               <input type="number" class="form-control" name="shapes[{index}].circle.center_x" step="0.001">
           </div>
           <div class="col-md-3 mb-3">
               <label class="form-label">åœ†å¿ƒY (Î¼m)</label>
               <input type="number" class="form-control" name="shapes[{index}].circle.center_y" step="0.001">
           </div>
           <div class="col-md-3 mb-3">
               <label class="form-label">åŠå¾„ (Î¼m)</label>
               <input type="number" class="form-control" name="shapes[{index}].circle.radius" step="0.001" min="0.001">
           </div>
           <div class="col-md-3 mb-3">
               <label class="form-label">ç²¾åº¦</label>
               <input type="number" class="form-control" name="shapes[{index}].circle.segments" value="64" min="8" max="256">
           </div>
       </div>
   </div>
   ```

2. **JavaScriptæ ¸å¿ƒç®—æ³•**
   ```javascript
   // åœ†å½¢é¡¶ç‚¹ç”Ÿæˆ
   function generateCircleVertices(centerX, centerY, radius, segments = 64) {
       const vertices = [];
       for (let i = 0; i < segments; i++) {
           const angle = (2 * Math.PI * i) / segments;
           const x = centerX + radius * Math.cos(angle);
           const y = centerY + radius * Math.sin(angle);
           vertices.push(`${x.toFixed(3)},${y.toFixed(3)}`);
       }
       return vertices.join(':');
   }

   // åŠ¨æ€è¡¨å•åˆ‡æ¢
   function toggleGeometryInputs(shapeIndex, geometryType) {
       const container = document.querySelector(`[data-shape-index="${shapeIndex}"]`);
       const verticesContainer = container.querySelector('.vertices-container');
       const circleContainer = container.querySelector('.circle-params-container');

       if (geometryType === 'circle') {
           verticesContainer.style.display = 'none';
           circleContainer.style.display = 'block';
       } else {
           verticesContainer.style.display = 'block';
           circleContainer.style.display = 'none';
       }
   }

   // å®æ—¶ç”Ÿæˆå’ŒéªŒè¯
   function updateVerticesFromCircle(shapeIndex) {
       const container = document.querySelector(`[data-shape-index="${shapeIndex}"]`);
       const centerX = parseFloat(container.querySelector('[name*="center_x"]').value) || 0;
       const centerY = parseFloat(container.querySelector('[name*="center_y"]').value) || 0;
       const radius = parseFloat(container.querySelector('[name*="radius"]').value);
       const segments = parseInt(container.querySelector('[name*="segments"]').value) || 64;

       if (radius > 0) {
           const vertices = generateCircleVertices(centerX, centerY, radius, segments);
           container.querySelector('[name*="vertices"]').value = vertices;
           updateJSONFromForm(); // è§¦å‘é…ç½®æ›´æ–°
       }
   }
   ```

#### éªŒæ”¶æ ‡å‡†
- âœ… UIåˆ‡æ¢æµç•…ï¼Œæ— å¡é¡¿
- âœ… åœ†å½¢å‚æ•°æ­£ç¡®ç”Ÿæˆé¡¶ç‚¹
- âœ… ç”Ÿæˆçš„GDSæ–‡ä»¶æ­£ç¡®æ˜¾ç¤ºåœ†å½¢
- âœ… åŸæœ‰é¡¶ç‚¹åŠŸèƒ½å®Œå…¨ä¸å—å½±å“

### é˜¶æ®µäºŒï¼šåŠŸèƒ½å¢å¼ºï¼ˆUIæ–¹æ¡ˆC + ç­–ç•¥3ï¼‰

#### å®ç°ç›®æ ‡
- æ”¯æŒåœ†å½¢å‚æ•°çš„åå‘ç¼–è¾‘
- ä¸ºæœªæ¥å½¢çŠ¶æ‰©å±•å¥ å®šåŸºç¡€
- æå‡é…ç½®æ–‡ä»¶çš„å¯ç»´æŠ¤æ€§

#### æŠ€æœ¯å®ç°
1. **å…ƒæ•°æ®ç»“æ„è®¾è®¡**
   ```javascript
   // æ‰©å±•é…ç½®ç”Ÿæˆ
   function generateShapeConfigWithMetadata(shapeData, geometryType) {
       const config = {
           type: shapeData.type,
           name: shapeData.name,
           layer: shapeData.layer,
           // ... å…¶ä»–åŸºç¡€å±æ€§
       };

       if (geometryType === 'circle') {
           // ç”Ÿæˆé¡¶ç‚¹
           config.vertices = generateCircleVertices(
               shapeData.center_x,
               shapeData.center_y,
               shapeData.radius,
               shapeData.segments
           );

           // ä¿å­˜å…ƒæ•°æ®
           config._metadata = {
               source: 'circle',
               params: {
                   center_x: shapeData.center_x,
                   center_y: shapeData.center_y,
                   radius: shapeData.radius,
                   segments: shapeData.segments
               },
               generated_at: new Date().toISOString()
           };
       } else {
           config.vertices = shapeData.vertices;
       }

       return config;
   }
   ```

2. **åå‘ç¼–è¾‘æ”¯æŒ**
   ```javascript
   // é…ç½®åŠ è½½æ—¶æ¢å¤UIçŠ¶æ€
   function restoreGeometryUIState(shape, index) {
       if (shape._metadata && shape._metadata.source === 'circle') {
           // è®¾ç½®ä¸ºåœ†å½¢æ¨¡å¼
           const geometrySelect = document.querySelector(`[name="shapes[${index}].geometry_type"]`);
           geometrySelect.value = 'circle';

           // æ¢å¤åœ†å½¢å‚æ•°
           const params = shape._metadata.params;
           const container = document.querySelector(`[data-shape-index="${index}"]`);
           container.querySelector('[name*="center_x"]').value = params.center_x;
           container.querySelector('[name*="center_y"]').value = params.center_y;
           container.querySelector('[name*="radius"]').value = params.radius;
           container.querySelector('[name*="segments"]').value = params.segments;

           // åˆ‡æ¢UIæ˜¾ç¤º
           toggleGeometryInputs(index, 'circle');
       }
   }
   ```

3. **åç«¯å…¼å®¹æ€§å¤„ç†**
   ```python
   # åœ¨ web_gui/app.py ä¸­æ·»åŠ 
   def ensure_metadata_compatibility(config_data):
       """ç¡®ä¿å…ƒæ•°æ®å…¼å®¹æ€§ï¼Œåç«¯å¿½ç•¥_metadataå­—æ®µ"""
       if isinstance(config_data, dict):
           # è®°å½•å…ƒæ•°æ®ç”¨äºè°ƒè¯•ï¼Œä½†ä¸å½±å“å¤„ç†
           if '_metadata' in config_data:
               logger.debug(f"Found metadata: {config_data['_metadata']}")

           for key, value in config_data.items():
               if isinstance(value, (dict, list)):
                   ensure_metadata_compatibility(value)
       elif isinstance(config_data, list):
           for item in config_data:
               ensure_metadata_compatibility(item)
       return config_data
   ```

## ğŸ”§ æ‰©å±•æ¶æ„è®¾è®¡

### å›¾å½¢ç”Ÿæˆå™¨æ¥å£
```javascript
// æŠ½è±¡å›¾å½¢ç”Ÿæˆå™¨åŸºç±»
class GeometryGenerator {
    constructor() {
        this.type = 'base';
    }

    // ç”Ÿæˆé¡¶ç‚¹çš„æŠ½è±¡æ–¹æ³•
    generateVertices(params) {
        throw new Error('generateVertices must be implemented');
    }

    // éªŒè¯å‚æ•°çš„æŠ½è±¡æ–¹æ³•
    validateParams(params) {
        throw new Error('validateParams must be implemented');
    }

    // è·å–é»˜è®¤å‚æ•°
    getDefaultParams() {
        return {};
    }
}

// åœ†å½¢ç”Ÿæˆå™¨
class CircleGenerator extends GeometryGenerator {
    constructor() {
        super();
        this.type = 'circle';
    }

    generateVertices(params) {
        const { center_x = 0, center_y = 0, radius, segments = 64 } = params;
        const vertices = [];

        for (let i = 0; i < segments; i++) {
            const angle = (2 * Math.PI * i) / segments;
            const x = center_x + radius * Math.cos(angle);
            const y = center_y + radius * Math.sin(angle);
            vertices.push(`${x.toFixed(3)},${y.toFixed(3)}`);
        }

        return vertices.join(':');
    }

    validateParams(params) {
        const errors = [];

        if (!params.radius || params.radius <= 0) {
            errors.push('åŠå¾„å¿…é¡»å¤§äº0');
        }

        if (params.segments && (params.segments < 8 || params.segments > 256)) {
            errors.push('ç²¾åº¦å¿…é¡»åœ¨8-256ä¹‹é—´');
        }

        return errors;
    }

    getDefaultParams() {
        return {
            center_x: 0,
            center_y: 0,
            radius: 10,
            segments: 64
        };
    }
}

// çŸ©å½¢ç”Ÿæˆå™¨ï¼ˆæœªæ¥æ‰©å±•ï¼‰
class RectangleGenerator extends GeometryGenerator {
    constructor() {
        super();
        this.type = 'rectangle';
    }

    generateVertices(params) {
        const { center_x = 0, center_y = 0, width, height } = params;
        const halfW = width / 2;
        const halfH = height / 2;

        return [
            `${center_x - halfW},${center_y - halfH}`,
            `${center_x + halfW},${center_y - halfH}`,
            `${center_x + halfW},${center_y + halfH}`,
            `${center_x - halfW},${center_y + halfH}`
        ].join(':');
    }

    validateParams(params) {
        const errors = [];

        if (!params.width || params.width <= 0) {
            errors.push('å®½åº¦å¿…é¡»å¤§äº0');
        }

        if (!params.height || params.height <= 0) {
            errors.push('é«˜åº¦å¿…é¡»å¤§äº0');
        }

        return errors;
    }

    getDefaultParams() {
        return {
            center_x: 0,
            center_y: 0,
            width: 20,
            height: 10
        };
    }
}

// ç”Ÿæˆå™¨å·¥å‚
class GeometryGeneratorFactory {
    static generators = new Map([
        ['circle', CircleGenerator],
        ['rectangle', RectangleGenerator]
    ]);

    static create(type) {
        const GeneratorClass = this.generators.get(type);
        if (!GeneratorClass) {
            throw new Error(`Unknown geometry type: ${type}`);
        }
        return new GeneratorClass();
    }

    static getSupportedTypes() {
        return Array.from(this.generators.keys());
    }
}
```

## ğŸ“Š æ–¹æ¡ˆä¼˜åŠ¿

### æŠ€æœ¯ä¼˜åŠ¿
1. **é£é™©å¯æ§**ï¼šæ¸è¿›å¼å®ç°ï¼Œæ¯é˜¶æ®µéƒ½æœ‰æ˜ç¡®éªŒæ”¶æ ‡å‡†
2. **å…¼å®¹æ€§å¥½**ï¼šå®Œå…¨ä¸å½±å“ç°æœ‰åŠŸèƒ½å’Œæ•°æ®æ ¼å¼
3. **æ‰©å±•æ€§å¼º**ï¼šä¸ºæœªæ¥æ·»åŠ æ›´å¤šå½¢çŠ¶æä¾›äº†æ¸…æ™°çš„æ¶æ„
4. **ç”¨æˆ·ä½“éªŒä¼˜**ï¼šç•Œé¢ç®€æ´ç›´è§‚ï¼Œå­¦ä¹ æˆæœ¬ä½

### å¼€å‘ä¼˜åŠ¿
1. **å¿«é€Ÿäº¤ä»˜**ï¼šé˜¶æ®µä¸€å¯åœ¨1-2å‘¨å†…å®Œæˆ
2. **é£é™©åˆ†æ•£**ï¼šåˆ†é˜¶æ®µéªŒè¯ï¼ŒåŠæ—¶è°ƒæ•´æ–¹å‘
3. **ä»£ç å¤ç”¨**ï¼šå……åˆ†åˆ©ç”¨ç°æœ‰æ¡†æ¶å’Œç»„ä»¶
4. **æµ‹è¯•å‹å¥½**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½æœ‰ç‹¬ç«‹çš„æµ‹è¯•ç›®æ ‡

### ç»´æŠ¤ä¼˜åŠ¿
1. **ä»£ç æ¸…æ™°**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼ŒèŒè´£åˆ†ç¦»æ˜ç¡®
2. **è°ƒè¯•å®¹æ˜“**ï¼šå…ƒæ•°æ®æä¾›äº†è¯¦ç»†çš„ç”Ÿæˆä¿¡æ¯
3. **æ–‡æ¡£å®Œå–„**ï¼šæ¯ä¸ªç»„ä»¶éƒ½æœ‰æ¸…æ™°çš„æ¥å£å®šä¹‰

è¿™ä¸ªæŠ€æœ¯æ–¹æ¡ˆä¸ºSummer-GDSçš„åœ†å½¢æ”¯æŒåŠŸèƒ½æä¾›äº†ä¸€ä¸ªç¨³å¥ã€å¯æ‰©å±•çš„å®ç°è·¯å¾„ï¼Œæ—¢èƒ½å¿«é€Ÿæ»¡è¶³å½“å‰éœ€æ±‚ï¼Œåˆä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å¥ å®šäº†åšå®åŸºç¡€ã€‚