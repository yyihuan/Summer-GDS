# 方案B属性覆盖系统 - 详细实施计划

## 实施策略概述

基于对现有代码的深入分析，方案B的实施具有高度复杂性。为了避免反复debug和难以定位问题，我们采用**8阶段渐进式实施**策略，每个阶段都有独立的测试验证点。

---

## 核心技术挑战分析

### 1. 代码改动热点识别

**高风险改动点**：
- `updateJSONFromForm()` (第477-616行) - 数据同步核心
- `renderShapeCard()` (第146-214行) - UI渲染核心
- `fillShapeFormValues()` (第295-437行) - 表单填充核心
- `offsetShape()` (第420-460行) - 派生形状创建核心

**低风险改动点**：
- 新增工具函数模块
- 新增UI组件
- 新增事件处理器

### 2. 技术约束条件

**必须保持的兼容性**：
```javascript
// 现有的config.shapes数据结构必须兼容
config.shapes = [
  {
    type: "polygon",
    name: "多边形1",
    vertices: "0,0:10,0:10,10:0,10",
    fillet: { type: "arc", radius: 5 },
    zoom: 0,
    layer: [1, 0]
  }
];
```

**性能要求**：
- 单次同步操作 < 100ms
- 支持50个形状的项目
- 不影响现有操作的响应速度

### 3. 关键风险点

**数据一致性风险**：
- 继承关系与实际数据不同步
- 覆盖状态丢失或错误

**UI状态风险**：
- 继承指示器与实际状态不符
- 表单输入状态混乱

**性能风险**：
- 频繁的DOM操作导致卡顿
- 大量形状时同步性能问题

---

## 8阶段实施计划

### 阶段1：基础架构搭建 (1-2天)

**目标**：建立核心数据结构和工具函数，不影响现有功能

**新增文件**：
```
web_gui/static/linkage/
├── core.js          # 核心工具函数
├── id-manager.js    # ID管理系统
├── property-path.js # 属性路径工具
└── validator.js     # 验证工具
```

**核心代码**：

**web_gui/static/linkage/core.js**：
```javascript
// 形状联动核心工具库
window.LinkageCore = {
    version: '1.0.0',
    debug: true,

    // 可继承属性路径配置
    INHERITABLE_PROPERTIES: [
        'vertices',
        'fillet.type',
        'fillet.radius',
        'fillet.radii',
        'fillet.precision',
        'fillet.convex_radius',
        'fillet.concave_radius',
        'zoom',
        '_metadata'
    ],

    // 属性路径工具
    getNestedProperty(obj, path) {
        if (!obj || !path) return undefined;
        return path.split('.').reduce((current, key) => current?.[key], obj);
    },

    setNestedProperty(obj, path, value) {
        if (!obj || !path) return;
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((current, key) => {
            if (!current[key]) current[key] = {};
            return current[key];
        }, obj);
        target[lastKey] = value;
    },

    // 深度比较
    deepEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return false;
        if (typeof a !== 'object' || typeof b !== 'object') return false;

        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;

        return keysA.every(key => this.deepEqual(a[key], b[key]));
    },

    // 日志工具
    log(level, message, data = null) {
        if (!this.debug) return;
        const timestamp = new Date().toISOString().substr(11, 12);
        console[level](`[Linkage ${timestamp}] ${message}`, data || '');
    }
};
```

**web_gui/static/linkage/id-manager.js**：
```javascript
// ID管理系统
window.LinkageIdManager = {
    idMap: new Map(),

    // 生成唯一ID
    generateShapeId() {
        return `shape_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },

    // 构建ID映射表
    buildIdMap(shapes) {
        this.idMap.clear();
        shapes.forEach((shape, index) => {
            if (!shape.id) {
                shape.id = this.generateShapeId();
                LinkageCore.log('info', `为形状生成ID: ${shape.name} -> ${shape.id}`);
            }
            this.idMap.set(shape.id, index);
        });
        LinkageCore.log('info', `ID映射表构建完成，包含${this.idMap.size}个形状`);
    },

    // 根据ID查找形状
    findShapeById(id, shapes) {
        const index = this.idMap.get(id);
        return index !== undefined ? shapes[index] : null;
    },

    // 查找派生形状
    findDerivedShapes(baseShapeId, shapes) {
        return shapes
            .map((shape, index) => ({ shape, index }))
            .filter(({ shape }) => shape.derivation?.base_shape_id === baseShapeId);
    },

    // 检测循环依赖
    detectCircularDependency(fromShapeId, toShapeId, shapes) {
        const visited = new Set();
        const stack = [toShapeId];

        while (stack.length > 0) {
            const currentId = stack.pop();
            if (visited.has(currentId)) continue;
            if (currentId === fromShapeId) return true;

            visited.add(currentId);
            const shape = this.findShapeById(currentId, shapes);
            if (shape?.derivation?.base_shape_id) {
                stack.push(shape.derivation.base_shape_id);
            }
        }
        return false;
    }
};
```

**阶段1验证点**：
1. 加载新JS文件不影响现有功能
2. ID管理系统能正确为现有形状分配ID
3. 属性路径工具正确读写嵌套属性
4. 循环依赖检测算法正确性

**测试用例**：
```javascript
// 在浏览器控制台验证
console.assert(LinkageCore.getNestedProperty({a: {b: 5}}, 'a.b') === 5);
console.assert(LinkageIdManager.generateShapeId().startsWith('shape_'));
```

---

### 阶段2：派生关系创建机制 (1天)

**目标**：修改`offsetShape()`和`confirmAddVia()`，支持创建具有派生关系的形状

**修改策略**：逐步增强，保持向后兼容

**offsetShape()增强版**：
```javascript
// 在原有函数基础上增加继承关系建立
function offsetShape(sourceIndex) {
    console.log(`开始扩大/缩小形状: 源索引=${sourceIndex}`);

    const sourceShape = config.shapes[sourceIndex];
    if (!sourceShape) {
        console.error('源形状不存在');
        showAlert('源形状不存在', 'danger');
        return;
    }

    // 确保源形状有ID
    if (!sourceShape.id) {
        sourceShape.id = LinkageIdManager.generateShapeId();
    }

    // 创建派生形状配置（新格式）
    const newShape = {
        type: sourceShape.type,
        id: LinkageIdManager.generateShapeId(),
        name: `${sourceShape.name}_扩大缩小`,
        layer: [
            (sourceShape.layer[0] || 1) + 1,
            sourceShape.layer[1] || 0
        ],

        // 新增：派生关系配置
        derivation: {
            base_shape_id: sourceShape.id,
            derive_type: 'offset',
            derive_params: {
                zoom: sourceShape.zoom || 0  // 派生参数
            },
            created_at: new Date().toISOString(),
            overrides: {}  // 初始无覆盖
        },

        // 运行时计算属性将在解析时生成
        _computed: {}
    };

    // 添加到配置中
    config.shapes.push(newShape);

    // 重建ID映射表
    LinkageIdManager.buildIdMap(config.shapes);

    // 解析并渲染新形状
    const resolvedShape = LinkagePropertyResolver.resolveShapeProperties(newShape);
    renderShapeCard(resolvedShape, config.shapes.length - 1);

    // 更新JSON编辑器和YAML预览
    jsonEditor.set(config);
    updateYAMLPreview();

    currentShapeIndex++;
    bindRadiusListToggleEvents();

    LinkageCore.log('info', `派生形状创建完成: ${newShape.name} <- ${sourceShape.name}`);
    showAlert('形状扩大/缩小成功', 'success', true);
}
```

**阶段2验证点**：
1. 新创建的派生形状具有正确的`derivation`结构
2. 原有形状创建流程不受影响
3. ID映射表正确维护
4. YAML输出包含新的派生关系数据

---

### 阶段3：属性解析引擎 (2天)

**目标**：实现核心的属性解析和计算逻辑

**新增文件**：`web_gui/static/linkage/property-resolver.js`

```javascript
// 属性解析引擎
window.LinkagePropertyResolver = {

    // 解析单个形状的属性
    resolveShapeProperties(shape) {
        if (!shape.derivation) {
            // 非派生形状，直接返回
            return { ...shape, _computed: this.extractComputedProps(shape) };
        }

        const baseShape = LinkageIdManager.findShapeById(
            shape.derivation.base_shape_id,
            config.shapes
        );

        if (!baseShape) {
            LinkageCore.log('error', `基础形状未找到: ${shape.derivation.base_shape_id}`);
            return shape;
        }

        const computed = {};

        // 解析所有可继承属性
        LinkageCore.INHERITABLE_PROPERTIES.forEach(propPath => {
            const override = shape.derivation.overrides?.[propPath];

            if (override?.overridden) {
                // 使用覆盖值
                LinkageCore.setNestedProperty(computed, propPath, override.value);
                LinkageCore.log('debug', `属性覆盖: ${shape.name}.${propPath} = ${JSON.stringify(override.value)}`);
            } else {
                // 使用继承值
                const inheritedValue = LinkageCore.getNestedProperty(baseShape, propPath);
                if (inheritedValue !== undefined) {
                    LinkageCore.setNestedProperty(computed, propPath, inheritedValue);
                    LinkageCore.log('debug', `属性继承: ${shape.name}.${propPath} = ${JSON.stringify(inheritedValue)}`);
                }
            }
        });

        // 应用派生参数（覆盖继承值）
        if (shape.derivation.derive_params) {
            Object.assign(computed, shape.derivation.derive_params);
            LinkageCore.log('debug', `应用派生参数: ${shape.name}`, shape.derivation.derive_params);
        }

        return {
            ...shape,
            _computed: computed
        };
    },

    // 提取计算属性
    extractComputedProps(shape) {
        const computed = {};
        LinkageCore.INHERITABLE_PROPERTIES.forEach(propPath => {
            const value = LinkageCore.getNestedProperty(shape, propPath);
            if (value !== undefined) {
                LinkageCore.setNestedProperty(computed, propPath, value);
            }
        });
        return computed;
    },

    // 批量解析所有形状
    resolveAllShapes(shapes) {
        LinkageIdManager.buildIdMap(shapes);
        return shapes.map(shape => this.resolveShapeProperties(shape));
    },

    // 检查属性是否被覆盖
    isPropertyOverridden(shape, propertyPath) {
        return shape.derivation?.overrides?.[propertyPath]?.overridden === true;
    },

    // 检查属性是否继承
    isPropertyInherited(shape, propertyPath) {
        if (!shape.derivation) return false;
        const override = shape.derivation.overrides?.[propertyPath];
        return !override?.overridden;
    },

    // 获取继承值
    getInheritedValue(shape, propertyPath) {
        if (!shape.derivation) return undefined;
        const baseShape = LinkageIdManager.findShapeById(
            shape.derivation.base_shape_id,
            config.shapes
        );
        return baseShape ? LinkageCore.getNestedProperty(baseShape, propertyPath) : undefined;
    }
};
```

**阶段3验证点**：
1. 属性解析引擎正确处理继承和覆盖
2. `_computed`属性正确计算
3. 性能测试：50个形状解析时间 < 50ms
4. 边界情况处理：缺失基础形状、无效属性路径

**测试用例**：
```javascript
// 创建测试数据
const testShape = {
    id: 'test-derived',
    derivation: {
        base_shape_id: 'test-base',
        overrides: {
            'fillet.radius': { value: 10, overridden: true }
        }
    }
};

const baseShape = {
    id: 'test-base',
    fillet: { type: 'arc', radius: 5 }
};

config.shapes = [baseShape, testShape];
const resolved = LinkagePropertyResolver.resolveShapeProperties(testShape);
console.assert(resolved._computed.fillet.radius === 10);  // 覆盖值
console.assert(resolved._computed.fillet.type === 'arc'); // 继承值
```

---

### 阶段4：变更检测与同步 (2天)

**目标**：实现核心的变更检测和同步机制

**关键挑战**：需要拦截`updateJSONFromForm()`而不破坏现有逻辑

**实施策略**：装饰器模式增强

```javascript
// 变更检测与同步模块
window.LinkageSyncManager = {

    // 增强updateJSONFromForm函数
    enhanceUpdateJSONFromForm() {
        const originalUpdate = window.updateJSONFromForm;

        window.updateJSONFromForm = function() {
            // 记录变化前的状态
            const oldShapes = JSON.parse(JSON.stringify(config.shapes));
            LinkageCore.log('info', '开始表单更新，记录变更前状态');

            // 执行原有更新逻辑
            originalUpdate.call(this);

            // 检测变化并触发同步
            setTimeout(() => {
                LinkageSyncManager.detectAndSync(oldShapes, config.shapes);
            }, 0);
        };

        LinkageCore.log('info', 'updateJSONFromForm函数已增强');
    },

    // 检测变化并同步
    detectAndSync(oldShapes, newShapes) {
        const changedShapes = this.detectChanges(oldShapes, newShapes);

        changedShapes.forEach(({ shapeId, changedProperties }) => {
            LinkageCore.log('info', `检测到形状变化: ${shapeId}`, changedProperties);
            this.syncDerivedShapes(shapeId, changedProperties);
        });
    },

    // 检测形状变化
    detectChanges(oldShapes, newShapes) {
        const changes = [];

        // 重建ID映射以确保正确索引
        LinkageIdManager.buildIdMap(newShapes);

        newShapes.forEach((newShape, index) => {
            if (!newShape.id) return;

            const oldShape = oldShapes.find(s => s.id === newShape.id);
            if (!oldShape) return;

            const changedProps = this.detectPropertyChanges(oldShape, newShape);
            if (changedProps.length > 0) {
                changes.push({
                    shapeId: newShape.id,
                    shapeName: newShape.name,
                    changedProperties: changedProps
                });
            }
        });

        return changes;
    },

    // 检测属性变化
    detectPropertyChanges(oldShape, newShape) {
        const changes = [];

        LinkageCore.INHERITABLE_PROPERTIES.forEach(propPath => {
            const oldValue = LinkageCore.getNestedProperty(oldShape, propPath);
            const newValue = LinkageCore.getNestedProperty(newShape, propPath);

            if (!LinkageCore.deepEqual(oldValue, newValue)) {
                changes.push(propPath);
                LinkageCore.log('debug', `属性变化检测: ${propPath}`, {
                    old: oldValue,
                    new: newValue
                });
            }
        });

        return changes;
    },

    // 同步派生形状
    syncDerivedShapes(baseShapeId, changedProperties) {
        const derivedShapes = LinkageIdManager.findDerivedShapes(baseShapeId, config.shapes);

        if (derivedShapes.length === 0) {
            LinkageCore.log('debug', `无派生形状需要同步: ${baseShapeId}`);
            return;
        }

        LinkageCore.log('info', `同步${derivedShapes.length}个派生形状`, {
            baseShapeId,
            changedProperties
        });

        derivedShapes.forEach(({ shape, index }) => {
            let needsUpdate = false;

            changedProperties.forEach(propPath => {
                const isOverridden = LinkagePropertyResolver.isPropertyOverridden(shape, propPath);

                if (!isOverridden) {
                    needsUpdate = true;
                    LinkageCore.log('debug', `同步属性: ${shape.name}.${propPath}`);
                } else {
                    LinkageCore.log('debug', `跳过已覆盖属性: ${shape.name}.${propPath}`);
                }
            });

            if (needsUpdate) {
                // 重新解析并更新UI
                const resolved = LinkagePropertyResolver.resolveShapeProperties(shape);
                this.updateShapeCardDisplay(index, resolved);
            }
        });

        // 更新JSON编辑器（避免递归）
        this.updateJSONEditorSilently();
    },

    // 更新形状卡片显示
    updateShapeCardDisplay(shapeIndex, resolvedShape) {
        const card = document.querySelector(`[data-shape-index="${shapeIndex}"]`);
        if (!card) {
            LinkageCore.log('warn', `未找到形状卡片: 索引${shapeIndex}`);
            return;
        }

        // 使用解析后的属性更新表单值
        this.updateFormValues(card, resolvedShape, shapeIndex);
        LinkageCore.log('debug', `已更新形状卡片显示: ${resolvedShape.name}`);
    },

    // 更新表单值
    updateFormValues(card, shape, index) {
        const computed = shape._computed || {};

        // 更新顶点
        if (computed.vertices !== undefined) {
            const verticesInput = card.querySelector(`[name="shapes[${index}].vertices"]`);
            if (verticesInput) verticesInput.value = computed.vertices;
        }

        // 更新倒角
        if (computed.fillet) {
            const typeSelect = card.querySelector(`[name="shapes[${index}].fillet.type"]`);
            if (typeSelect && computed.fillet.type) {
                typeSelect.value = computed.fillet.type;
            }

            const radiusInput = card.querySelector(`[name="shapes[${index}].fillet.radius"]`);
            if (radiusInput && computed.fillet.radius !== undefined) {
                radiusInput.value = computed.fillet.radius;
            }
        }

        // 更新zoom
        if (computed.zoom !== undefined) {
            const zoomInput = card.querySelector(`[name="shapes[${index}].zoom"]`);
            if (zoomInput) zoomInput.value = computed.zoom;
        }
    },

    // 静默更新JSON编辑器（避免触发事件）
    updateJSONEditorSilently() {
        if (jsonEditor && jsonEditor.set) {
            // 临时移除事件监听器
            const originalOnChange = jsonEditor.options.onChangeJSON;
            jsonEditor.options.onChangeJSON = null;

            jsonEditor.set(config);

            // 恢复事件监听器
            jsonEditor.options.onChangeJSON = originalOnChange;
        }

        // 更新YAML预览
        updateYAMLPreview();
    }
};
```

**阶段4验证点**：
1. 变更检测准确识别属性变化
2. 同步机制正确更新派生形状
3. 不出现递归更新问题
4. 性能测试：10个派生形状同步时间 < 50ms

---

### 阶段5：用户覆盖机制 (1-2天)

**目标**：实现用户手动修改检测和覆盖记录

**关键挑战**：需要区分"用户主动修改"和"系统同步更新"

**实施策略**：事件标记法

```javascript
// 用户覆盖管理器
window.LinkageOverrideManager = {
    isSystemUpdate: false,  // 标记是否为系统更新

    // 增强表单事件绑定
    enhanceFormEventBinding() {
        const originalBind = window.bindShapeCardEvents;

        window.bindShapeCardEvents = function(cardElement, shape, index) {
            // 调用原有绑定
            originalBind.call(this, cardElement, shape, index);

            // 添加覆盖检测
            LinkageOverrideManager.addOverrideDetection(cardElement, shape, index);
        };

        LinkageCore.log('info', '表单事件绑定已增强');
    },

    // 添加覆盖检测
    addOverrideDetection(cardElement, shape, index) {
        if (!shape.derivation) return;  // 非派生形状跳过

        // 为可继承属性的输入框添加覆盖检测
        LinkageCore.INHERITABLE_PROPERTIES.forEach(propPath => {
            const inputSelectors = this.getInputSelectorsForProperty(propPath, index);

            inputSelectors.forEach(selector => {
                const input = cardElement.querySelector(selector);
                if (input) {
                    this.bindOverrideDetection(input, shape, propPath, index);
                }
            });
        });
    },

    // 获取属性对应的输入框选择器
    getInputSelectorsForProperty(propPath, index) {
        const selectors = [];

        switch (propPath) {
            case 'vertices':
                selectors.push(`[name="shapes[${index}].vertices"]`);
                break;
            case 'fillet.type':
                selectors.push(`[name="shapes[${index}].fillet.type"]`);
                break;
            case 'fillet.radius':
                selectors.push(`[name="shapes[${index}].fillet.radius"]`);
                break;
            case 'fillet.radii':
                selectors.push(`[name="shapes[${index}].fillet.radii"]`);
                break;
            case 'zoom':
                selectors.push(`[name="shapes[${index}].zoom"]`);
                break;
        }

        return selectors;
    },

    // 绑定覆盖检测
    bindOverrideDetection(input, shape, propertyPath, shapeIndex) {
        const originalValue = input.value;

        input.addEventListener('change', (event) => {
            // 跳过系统更新
            if (this.isSystemUpdate) {
                LinkageCore.log('debug', `跳过系统更新: ${propertyPath}`);
                return;
            }

            const newValue = this.parseInputValue(event.target);
            this.handleUserOverride(shape, propertyPath, newValue, shapeIndex);
        });

        // 添加焦点事件，用于更精确的用户意图检测
        input.addEventListener('focus', () => {
            this.lastFocusedInput = { shape, propertyPath, shapeIndex };
        });
    },

    // 解析输入值
    parseInputValue(input) {
        const value = input.value;
        const type = input.type;

        if (type === 'number') {
            return parseFloat(value) || 0;
        } else if (input.tagName === 'SELECT') {
            return value;
        } else {
            return value;
        }
    },

    // 处理用户覆盖
    handleUserOverride(shape, propertyPath, newValue, shapeIndex) {
        if (!shape.derivation) return;

        // 获取当前继承值
        const inheritedValue = LinkagePropertyResolver.getInheritedValue(shape, propertyPath);

        // 检查新值是否与继承值不同
        if (!LinkageCore.deepEqual(newValue, inheritedValue)) {
            // 创建覆盖记录
            this.createOverride(shape, propertyPath, newValue, inheritedValue);

            // 更新UI指示器
            this.updateInheritanceIndicator(shapeIndex, propertyPath, 'overridden');

            LinkageCore.log('info', `用户覆盖属性: ${shape.name}.${propertyPath}`, {
                newValue,
                inheritedValue
            });

            showAlert(`属性 ${propertyPath} 已覆盖，不再跟随基础形状`, 'info');
        } else {
            // 新值与继承值相同，移除覆盖
            this.removeOverride(shape, propertyPath);

            // 更新UI指示器
            this.updateInheritanceIndicator(shapeIndex, propertyPath, 'inherited');

            LinkageCore.log('info', `恢复属性继承: ${shape.name}.${propertyPath}`);
            showAlert(`属性 ${propertyPath} 已恢复继承`, 'success');
        }

        // 更新配置
        updateJSONFromForm();
    },

    // 创建覆盖记录
    createOverride(shape, propertyPath, value, previousInheritedValue) {
        if (!shape.derivation.overrides) {
            shape.derivation.overrides = {};
        }

        shape.derivation.overrides[propertyPath] = {
            value: value,
            overridden: true,
            overridden_at: new Date().toISOString(),
            reason: 'user_manual_edit',
            previous_inherited_value: previousInheritedValue
        };
    },

    // 移除覆盖记录
    removeOverride(shape, propertyPath) {
        if (shape.derivation.overrides && shape.derivation.overrides[propertyPath]) {
            delete shape.derivation.overrides[propertyPath];
        }
    },

    // 更新继承指示器
    updateInheritanceIndicator(shapeIndex, propertyPath, status) {
        const card = document.querySelector(`[data-shape-index="${shapeIndex}"]`);
        if (!card) return;

        const indicator = card.querySelector(`[data-inheritance-indicator="${propertyPath}"]`);
        if (!indicator) return;

        if (status === 'inherited') {
            indicator.className = 'badge bg-success';
            indicator.innerHTML = '<i class="bi bi-link"></i> 继承中';
            indicator.title = '当前继承自基础形状，自动同步';
        } else if (status === 'overridden') {
            indicator.className = 'badge bg-warning';
            indicator.innerHTML = '<i class="bi bi-pencil-fill"></i> 已覆盖';
            indicator.title = '已手动覆盖，不再同步';
        }
    }
};
```

**阶段5验证点**：
1. 用户修改正确触发覆盖机制
2. 系统同步不触发覆盖检测
3. 覆盖记录格式正确
4. UI指示器正确反映继承状态

---

### 阶段6：UI增强与指示器 (1-2天)

**目标**：实现继承状态的可视化指示和操作按钮

**修改策略**：扩展现有模板，添加新组件

**HTML模板增强**：
```html
<!-- 倒角参数输入框增强版 -->
<div class="row">
  <div class="col-md-6 mb-3">
    <label class="form-label">
      倒角半径
      <!-- 继承状态徽章 -->
      <span class="inheritance-indicator"
            data-inheritance-indicator="fillet.radius"
            data-shape-index="{index}">
        <span class="badge bg-secondary">检测中...</span>
      </span>
    </label>

    <div class="input-group">
      <input type="number"
             class="form-control"
             name="shapes[{index}].fillet.radius"
             data-linkage-property="fillet.radius">

      <!-- 恢复继承按钮 -->
      <button type="button"
              class="btn btn-outline-secondary restore-inheritance-btn"
              data-shape-index="{index}"
              data-property-path="fillet.radius"
              style="display: none;">
        <i class="bi bi-arrow-counterclockwise"></i>
      </button>

      <!-- 查看差异按钮 -->
      <button type="button"
              class="btn btn-outline-info view-diff-btn"
              data-shape-index="{index}"
              data-property-path="fillet.radius"
              style="display: none;">
        <i class="bi bi-file-diff"></i>
      </button>
    </div>

    <!-- 继承值预览 -->
    <small class="form-text text-muted inherited-value-preview"
           data-shape-index="{index}"
           data-property-path="fillet.radius"
           style="display: none;">
      继承值: <span class="inherited-value"></span>
    </small>
  </div>
</div>
```

**UI管理器**：
```javascript
// UI增强管理器
window.LinkageUIManager = {

    // 初始化UI增强
    initializeUI() {
        this.addGlobalStyles();
        this.bindGlobalEvents();
        LinkageCore.log('info', 'UI增强初始化完成');
    },

    // 添加全局样式
    addGlobalStyles() {
        const styles = `
        <style id="linkage-ui-styles">
        .inheritance-indicator {
            margin-left: 8px;
        }

        .inherited-value-preview {
            font-size: 0.875em;
        }

        .property-field.inherited .form-control {
            border-left: 3px solid #198754;
        }

        .property-field.overridden .form-control {
            border-left: 3px solid #ffc107;
        }

        .linkage-diff-modal .diff-highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        </style>`;

        if (!document.getElementById('linkage-ui-styles')) {
            document.head.insertAdjacentHTML('beforeend', styles);
        }
    },

    // 绑定全局事件
    bindGlobalEvents() {
        // 恢复继承按钮事件
        document.addEventListener('click', (e) => {
            if (e.target.closest('.restore-inheritance-btn')) {
                const btn = e.target.closest('.restore-inheritance-btn');
                const shapeIndex = btn.dataset.shapeIndex;
                const propertyPath = btn.dataset.propertyPath;
                this.restoreInheritance(shapeIndex, propertyPath);
            }
        });

        // 查看差异按钮事件
        document.addEventListener('click', (e) => {
            if (e.target.closest('.view-diff-btn')) {
                const btn = e.target.closest('.view-diff-btn');
                const shapeIndex = btn.dataset.shapeIndex;
                const propertyPath = btn.dataset.propertyPath;
                this.showPropertyDiff(shapeIndex, propertyPath);
            }
        });
    },

    // 更新形状的UI指示器
    updateShapeIndicators(shapeIndex, shape) {
        const card = document.querySelector(`[data-shape-index="${shapeIndex}"]`);
        if (!card || !shape.derivation) return;

        LinkageCore.INHERITABLE_PROPERTIES.forEach(propPath => {
            this.updatePropertyIndicator(card, shape, propPath, shapeIndex);
        });
    },

    // 更新属性指示器
    updatePropertyIndicator(card, shape, propertyPath, shapeIndex) {
        const indicator = card.querySelector(`[data-inheritance-indicator="${propertyPath}"]`);
        const restoreBtn = card.querySelector(`[data-property-path="${propertyPath}"].restore-inheritance-btn`);
        const diffBtn = card.querySelector(`[data-property-path="${propertyPath}"].view-diff-btn`);
        const preview = card.querySelector(`[data-property-path="${propertyPath}"].inherited-value-preview`);

        if (!indicator) return;

        const isOverridden = LinkagePropertyResolver.isPropertyOverridden(shape, propertyPath);
        const inheritedValue = LinkagePropertyResolver.getInheritedValue(shape, propertyPath);

        if (isOverridden) {
            // 已覆盖状态
            indicator.innerHTML = '<span class="badge bg-warning"><i class="bi bi-pencil-fill"></i> 已覆盖</span>';
            indicator.title = '已手动覆盖，不再自动同步';

            if (restoreBtn) restoreBtn.style.display = 'inline-block';
            if (diffBtn) diffBtn.style.display = 'inline-block';
            if (preview) {
                preview.style.display = 'block';
                preview.querySelector('.inherited-value').textContent = JSON.stringify(inheritedValue);
            }

            // 添加CSS类
            const fieldContainer = indicator.closest('.property-field') || indicator.closest('.col-md-6');
            if (fieldContainer) {
                fieldContainer.classList.add('overridden');
                fieldContainer.classList.remove('inherited');
            }
        } else {
            // 继承状态
            indicator.innerHTML = '<span class="badge bg-success"><i class="bi bi-link"></i> 继承中</span>';
            indicator.title = '继承自基础形状，自动同步';

            if (restoreBtn) restoreBtn.style.display = 'none';
            if (diffBtn) diffBtn.style.display = 'none';
            if (preview) preview.style.display = 'none';

            // 添加CSS类
            const fieldContainer = indicator.closest('.property-field') || indicator.closest('.col-md-6');
            if (fieldContainer) {
                fieldContainer.classList.add('inherited');
                fieldContainer.classList.remove('overridden');
            }
        }
    },

    // 恢复继承
    restoreInheritance(shapeIndex, propertyPath) {
        const shape = config.shapes[shapeIndex];
        if (!shape.derivation) return;

        const override = shape.derivation.overrides?.[propertyPath];
        if (!override) {
            showAlert('该属性未被覆盖，无需恢复', 'info');
            return;
        }

        const inheritedValue = LinkagePropertyResolver.getInheritedValue(shape, propertyPath);

        const confirmed = confirm(
            `确认恢复继承？\n\n` +
            `当前值: ${JSON.stringify(override.value)}\n` +
            `将变为: ${JSON.stringify(inheritedValue)}\n\n` +
            `恢复后，该属性将跟随基础形状自动更新。`
        );

        if (!confirmed) return;

        // 删除覆盖记录
        delete shape.derivation.overrides[propertyPath];

        // 更新表单值
        LinkageOverrideManager.isSystemUpdate = true;
        const resolved = LinkagePropertyResolver.resolveShapeProperties(shape);
        LinkageSyncManager.updateFormValues(
            document.querySelector(`[data-shape-index="${shapeIndex}"]`),
            resolved,
            shapeIndex
        );
        LinkageOverrideManager.isSystemUpdate = false;

        // 更新UI指示器
        this.updatePropertyIndicator(
            document.querySelector(`[data-shape-index="${shapeIndex}"]`),
            shape,
            propertyPath,
            shapeIndex
        );

        // 更新配置
        updateJSONFromForm();

        showAlert(`属性 ${propertyPath} 已恢复继承`, 'success');
        LinkageCore.log('info', `恢复继承: ${shape.name}.${propertyPath}`);
    },

    // 显示属性差异
    showPropertyDiff(shapeIndex, propertyPath) {
        const shape = config.shapes[shapeIndex];
        const override = shape.derivation.overrides[propertyPath];
        const inheritedValue = LinkagePropertyResolver.getInheritedValue(shape, propertyPath);

        const modalHtml = `
        <div class="modal fade linkage-diff-modal" tabindex="-1">
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">属性差异: ${propertyPath}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
              </div>
              <div class="modal-body">
                <div class="row">
                  <div class="col-6">
                    <h6>当前值 (已覆盖)</h6>
                    <div class="diff-highlight">${JSON.stringify(override.value, null, 2)}</div>
                  </div>
                  <div class="col-6">
                    <h6>继承值</h6>
                    <div>${JSON.stringify(inheritedValue, null, 2)}</div>
                  </div>
                </div>
                <hr>
                <small class="text-muted">
                  覆盖时间: ${new Date(override.overridden_at).toLocaleString()}<br>
                  原因: ${override.reason}
                </small>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                <button type="button" class="btn btn-primary"
                        onclick="LinkageUIManager.restoreInheritance('${shapeIndex}', '${propertyPath}'); bootstrap.Modal.getInstance(this.closest('.modal')).hide();">
                  恢复继承
                </button>
              </div>
            </div>
          </div>
        </div>`;

        // 移除已存在的模态框
        const existingModal = document.querySelector('.linkage-diff-modal');
        if (existingModal) existingModal.remove();

        // 添加新模态框
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.querySelector('.linkage-diff-modal'));
        modal.show();
    }
};
```

**阶段6验证点**：
1. 继承状态指示器正确显示
2. 恢复继承按钮功能正常
3. 差异对比对话框正确显示
4. UI样式美观一致

---

### 阶段7：集成测试与优化 (1天)

**目标**：整合所有模块，进行全面测试和性能优化

**主入口文件**：`web_gui/static/linkage/main.js`

```javascript
// 形状联动系统主入口
window.LinkageSystem = {
    initialized: false,

    // 初始化系统
    init() {
        if (this.initialized) {
            LinkageCore.log('warn', '联动系统已初始化，跳过重复初始化');
            return;
        }

        try {
            // 初始化各模块
            LinkageUIManager.initializeUI();
            LinkageSyncManager.enhanceUpdateJSONFromForm();
            LinkageOverrideManager.enhanceFormEventBinding();

            // 为现有形状补充ID
            LinkageIdManager.buildIdMap(config.shapes);

            // 添加页面卸载清理
            window.addEventListener('beforeunload', () => {
                this.cleanup();
            });

            this.initialized = true;
            LinkageCore.log('info', '形状联动系统初始化完成');

            // 显示初始化成功提示
            showAlert('形状联动功能已启用', 'success');

        } catch (error) {
            LinkageCore.log('error', '联动系统初始化失败', error);
            showAlert('形状联动功能启用失败: ' + error.message, 'danger');
        }
    },

    // 清理资源
    cleanup() {
        LinkageCore.log('info', '清理联动系统资源');
        // 清理事件监听器、定时器等
    },

    // 系统状态检查
    healthCheck() {
        const checks = {
            idMap: LinkageIdManager.idMap.size > 0,
            enhancedUpdate: typeof window.updateJSONFromForm === 'function',
            uiStyles: document.getElementById('linkage-ui-styles') !== null
        };

        const allPassed = Object.values(checks).every(Boolean);

        LinkageCore.log('info', '系统健康检查', { checks, allPassed });
        return { checks, allPassed };
    },

    // 性能统计
    getPerformanceStats() {
        return {
            totalShapes: config.shapes.length,
            derivedShapes: config.shapes.filter(s => s.derivation).length,
            idMapSize: LinkageIdManager.idMap.size,
            memoryUsage: performance.memory ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
            } : 'Not available'
        };
    }
};

// 自动初始化（在DOMContentLoaded之后）
document.addEventListener('DOMContentLoaded', () => {
    // 延迟初始化，确保其他模块已加载
    setTimeout(() => {
        LinkageSystem.init();
    }, 1000);
});
```

**性能测试用例**：
```javascript
// 性能测试工具
window.LinkagePerformanceTest = {

    // 创建测试数据
    createTestData(baseShapeCount, derivedPerBase) {
        const testShapes = [];

        // 创建基础形状
        for (let i = 0; i < baseShapeCount; i++) {
            testShapes.push({
                id: `base-${i}`,
                type: 'polygon',
                name: `基础形状${i}`,
                vertices: '0,0:10,0:10,10:0,10',
                fillet: { type: 'arc', radius: 5 },
                zoom: 0,
                layer: [i + 1, 0]
            });
        }

        // 创建派生形状
        for (let i = 0; i < baseShapeCount; i++) {
            for (let j = 0; j < derivedPerBase; j++) {
                testShapes.push({
                    id: `derived-${i}-${j}`,
                    type: 'polygon',
                    name: `派生形状${i}-${j}`,
                    layer: [i + 1 + j + 1, 0],
                    derivation: {
                        base_shape_id: `base-${i}`,
                        derive_type: 'offset',
                        derive_params: { zoom: j + 1 },
                        created_at: new Date().toISOString(),
                        overrides: {}
                    }
                });
            }
        }

        return testShapes;
    },

    // 测试属性解析性能
    testPropertyResolution(shapes) {
        const start = performance.now();
        const resolved = LinkagePropertyResolver.resolveAllShapes(shapes);
        const end = performance.now();

        return {
            duration: end - start,
            shapesCount: shapes.length,
            averagePerShape: (end - start) / shapes.length
        };
    },

    // 测试同步性能
    testSyncPerformance(shapes) {
        config.shapes = shapes;
        LinkageIdManager.buildIdMap(shapes);

        const start = performance.now();

        // 模拟基础形状变化
        shapes[0].fillet.radius = 10;
        LinkageSyncManager.syncDerivedShapes(shapes[0].id, ['fillet.radius']);

        const end = performance.now();

        return {
            duration: end - start,
            derivedShapesCount: shapes.filter(s => s.derivation?.base_shape_id === shapes[0].id).length
        };
    },

    // 运行完整性能测试
    runFullTest() {
        console.log('开始性能测试...');

        const scenarios = [
            { bases: 10, derived: 3 },
            { bases: 20, derived: 5 },
            { bases: 30, derived: 5 }
        ];

        scenarios.forEach(scenario => {
            const shapes = this.createTestData(scenario.bases, scenario.derived);
            const resolveResult = this.testPropertyResolution(shapes);
            const syncResult = this.testSyncPerformance(shapes);

            console.log(`场景: ${scenario.bases}基础 × ${scenario.derived}派生`, {
                总形状数: shapes.length,
                解析耗时: resolveResult.duration.toFixed(2) + 'ms',
                平均解析: resolveResult.averagePerShape.toFixed(2) + 'ms/形状',
                同步耗时: syncResult.duration.toFixed(2) + 'ms',
                同步形状数: syncResult.derivedShapesCount
            });
        });
    }
};
```

**阶段7验证点**：
1. 系统健康检查全部通过
2. 性能测试满足要求（单次同步<100ms）
3. 内存使用合理（无明显泄漏）
4. 所有功能集成正常

---

### 阶段8：生产部署与监控 (1天)

**目标**：完成生产环境部署和监控机制

**部署检查清单**：
```javascript
// 部署检查工具
window.LinkageDeploymentCheck = {

    // 执行部署前检查
    preDeploymentCheck() {
        const checks = [
            this.checkJSFileLoading(),
            this.checkExistingFunctionality(),
            this.checkConfigCompatibility(),
            this.checkPerformance(),
            this.checkUICompatibility()
        ];

        const results = checks.map(check => check());
        const allPassed = results.every(r => r.passed);

        console.log('部署前检查结果:', results);
        return { results, allPassed };
    },

    // 检查JS文件加载
    checkJSFileLoading() {
        const requiredModules = [
            'LinkageCore',
            'LinkageIdManager',
            'LinkagePropertyResolver',
            'LinkageSyncManager',
            'LinkageOverrideManager',
            'LinkageUIManager',
            'LinkageSystem'
        ];

        const missing = requiredModules.filter(module => typeof window[module] === 'undefined');

        return {
            name: 'JS模块加载',
            passed: missing.length === 0,
            details: missing.length > 0 ? `缺失模块: ${missing.join(', ')}` : '所有模块已加载'
        };
    },

    // 检查现有功能
    checkExistingFunctionality() {
        try {
            // 测试现有功能是否正常
            const originalShapeCount = config.shapes.length;

            // 模拟添加形状
            addShape('polygon');
            const afterAddCount = config.shapes.length;

            // 清理测试数据
            config.shapes.pop();

            return {
                name: '现有功能兼容性',
                passed: afterAddCount === originalShapeCount + 1,
                details: '形状添加功能正常'
            };
        } catch (error) {
            return {
                name: '现有功能兼容性',
                passed: false,
                details: `功能异常: ${error.message}`
            };
        }
    },

    // 检查配置兼容性
    checkConfigCompatibility() {
        const sampleOldConfig = {
            shapes: [{
                type: 'polygon',
                name: '测试形状',
                vertices: '0,0:10,0:10,10:0,10',
                fillet: { type: 'arc', radius: 5 },
                zoom: 0,
                layer: [1, 0]
            }]
        };

        try {
            const oldConfig = JSON.parse(JSON.stringify(config));
            config.shapes = sampleOldConfig.shapes;

            LinkageIdManager.buildIdMap(config.shapes);
            const resolved = LinkagePropertyResolver.resolveAllShapes(config.shapes);

            // 恢复原配置
            config.shapes = oldConfig.shapes;

            return {
                name: '旧配置兼容性',
                passed: resolved.length === 1 && resolved[0].id,
                details: '旧格式配置可正常处理'
            };
        } catch (error) {
            return {
                name: '旧配置兼容性',
                passed: false,
                details: `兼容性异常: ${error.message}`
            };
        }
    },

    // 检查性能
    checkPerformance() {
        const start = performance.now();

        // 模拟中等复杂度操作
        const testShapes = LinkagePerformanceTest.createTestData(10, 3);
        LinkagePropertyResolver.resolveAllShapes(testShapes);

        const duration = performance.now() - start;

        return {
            name: '性能检查',
            passed: duration < 200,  // 200ms阈值
            details: `30个形状解析耗时: ${duration.toFixed(2)}ms`
        };
    },

    // 检查UI兼容性
    checkUICompatibility() {
        const hasStyles = document.getElementById('linkage-ui-styles') !== null;
        const hasBootstrap = typeof bootstrap !== 'undefined';

        return {
            name: 'UI兼容性',
            passed: hasStyles && hasBootstrap,
            details: `样式: ${hasStyles ? '✓' : '✗'}, Bootstrap: ${hasBootstrap ? '✓' : '✗'}`
        };
    }
};

// 监控机制
window.LinkageMonitor = {
    enabled: true,
    stats: {
        operationCount: 0,
        errorCount: 0,
        averageResponseTime: 0,
        lastOperationTime: null
    },

    // 记录操作
    recordOperation(operationType, duration, success = true) {
        if (!this.enabled) return;

        this.stats.operationCount++;
        this.stats.lastOperationTime = new Date();

        if (!success) {
            this.stats.errorCount++;
        }

        // 更新平均响应时间
        if (duration) {
            const currentAvg = this.stats.averageResponseTime;
            const count = this.stats.operationCount;
            this.stats.averageResponseTime = (currentAvg * (count - 1) + duration) / count;
        }

        // 记录详细日志
        LinkageCore.log('info', `操作统计: ${operationType}`, {
            duration: duration ? `${duration.toFixed(2)}ms` : 'N/A',
            success,
            totalOps: this.stats.operationCount,
            errorRate: `${(this.stats.errorCount / this.stats.operationCount * 100).toFixed(1)}%`
        });
    },

    // 获取统计报告
    getStatsReport() {
        return {
            ...this.stats,
            errorRate: this.stats.operationCount > 0 ?
                (this.stats.errorCount / this.stats.operationCount * 100).toFixed(1) + '%' :
                '0%',
            averageResponseTime: this.stats.averageResponseTime.toFixed(2) + 'ms'
        };
    },

    // 重置统计
    resetStats() {
        this.stats = {
            operationCount: 0,
            errorCount: 0,
            averageResponseTime: 0,
            lastOperationTime: null
        };
        LinkageCore.log('info', '监控统计已重置');
    }
};
```

**HTML模板修改指南**：在`web_gui/templates/index.html`中添加：

```html
<!-- 在head部分添加联动系统CSS和JS文件 -->
<head>
    <!-- 现有内容... -->

    <!-- 形状联动系统 -->
    <script src="{{ url_for('static', filename='linkage/core.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/id-manager.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/property-resolver.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/sync-manager.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/override-manager.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/ui-manager.js') }}"></script>
    <script src="{{ url_for('static', filename='linkage/main.js') }}"></script>
</head>
```

**阶段8验证点**：
1. 部署前检查全部通过
2. 生产环境功能正常
3. 监控机制正确工作
4. 错误处理和日志记录完善

---

## 实施风险控制

### 1. 回滚策略

**快速回滚机制**：
```javascript
// 联动系统禁用开关
window.LINKAGE_SYSTEM_ENABLED = true;

// 在每个模块入口添加开关检查
if (!window.LINKAGE_SYSTEM_ENABLED) {
    console.warn('联动系统已禁用');
    return;
}
```

**配置标记**：在HTML中添加功能开关
```html
<script>
    // 可通过修改此值快速禁用联动功能
    window.LINKAGE_SYSTEM_ENABLED = true;
</script>
```

### 2. 渐进式启用

**用户友好的启用流程**：
1. 系统自动检测是否有派生形状
2. 如有，显示提示："检测到形状衍生关系，是否启用智能联动？"
3. 用户确认后再激活联动系统
4. 提供"稍后启用"选项

### 3. 详细错误处理

**错误分类与处理**：
```javascript
window.LinkageErrorHandler = {
    handleError(error, context) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString(),
            systemState: LinkageSystem.getPerformanceStats()
        };

        // 根据错误严重程度分类处理
        if (this.isCriticalError(error)) {
            // 关键错误：禁用系统
            window.LINKAGE_SYSTEM_ENABLED = false;
            showAlert('联动系统遇到严重错误，已自动禁用', 'danger');
            console.error('联动系统关键错误:', errorInfo);
        } else {
            // 一般错误：记录并继续
            showAlert(`联动功能异常: ${error.message}`, 'warning');
            LinkageCore.log('error', '联动系统错误', errorInfo);
        }

        // 发送错误报告（如果需要）
        this.reportError(errorInfo);
    },

    isCriticalError(error) {
        const criticalMessages = [
            'Cannot read property',
            'Stack overflow',
            'Maximum call stack'
        ];
        return criticalMessages.some(msg => error.message.includes(msg));
    },

    reportError(errorInfo) {
        // 可选：发送到错误监控服务
        console.log('错误报告已生成:', errorInfo);
    }
};
```

---

## 测试策略

### 1. 单元测试

**每个阶段的测试用例**：
- 阶段1-2：基础功能测试
- 阶段3-4：属性解析和同步测试
- 阶段5-6：UI交互测试
- 阶段7-8：集成和性能测试

### 2. 浏览器兼容性测试

**支持的浏览器**：
- Chrome 80+
- Firefox 75+
- Safari 13+
- Edge 80+

### 3. 性能基准测试

**测试场景**：
- 10个基础形状 + 30个派生形状
- 单次属性修改触发的同步时间
- 大批量形状解析性能
- 内存使用情况

---

## 文档和培训

### 1. 开发者文档

**技术文档结构**：
```
docs/linkage/
├── README.md              # 概述和快速开始
├── architecture.md        # 架构设计说明
├── api-reference.md       # API参考文档
├── troubleshooting.md     # 故障排除指南
└── performance-tuning.md  # 性能优化建议
```

### 2. 用户手册

**用户指导内容**：
- 什么是形状联动
- 如何创建派生形状
- 如何管理继承关系
- 常见问题解答

---

## 总结

本实施计划通过8个阶段的渐进式开发，确保：

1. **风险可控**：每个阶段都有独立的验证点
2. **功能完整**：覆盖方案B的所有核心功能
3. **性能优化**：满足50个形状<100ms的性能要求
4. **向后兼容**：不破坏现有功能和配置
5. **可维护性**：模块化设计，便于后续扩展

总开发时间：**8-12天**
团队建议：**2名前端开发者**
测试时间：**3-4天**

通过这个详细的分步计划，可以有效避免反复debug和难以定位的问题，确保方案B的成功实施。