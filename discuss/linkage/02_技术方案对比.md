# 形状联动同步 - 技术方案对比

## 方案概览

基于需求分析，我们提出了两个核心技术方案：
- **方案A**：轻量级标记位方案（便于实施）
- **方案B**：属性覆盖系统（更健壮）

以下详细对比两个方案的设计、实现和权衡。

---

## 方案A：轻量级标记位方案

### 设计理念

采用**最小改动原则**，通过添加简单的标记位来实现继承控制，不改变现有的数据流和业务逻辑。

### 数据结构设计

```yaml
# 原始形状
shapes:
  - type: polygon
    name: 基础多边形
    id: shape_abc123  # 新增：唯一标识符
    vertices: "0,0:10,0:10,10:0,10"
    fillet:
      type: arc
      radius: 5
    zoom: 0

  - type: polygon
    name: 基础多边形_扩大
    id: shape_def456
    base_shape_id: shape_abc123  # 新增：指向基础形状
    derive_type: offset  # 新增：派生类型

    vertices: "0,0:10,0:10,10:0,10"  # 继承的数据
    vertices_inherited: true  # 新增：继承标记

    fillet:
      type: arc
      radius: 5
      inherited: true  # 新增：继承标记

    zoom: 2  # 派生参数：独立设置
```

### 核心机制

#### 1. ID管理系统

```javascript
// ID生成器
function generateShapeId() {
  return `shape_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// ID到索引的映射表（运行时维护）
const shapeIdMap = new Map();

function buildShapeIdMap() {
  shapeIdMap.clear();
  config.shapes.forEach((shape, index) => {
    if (!shape.id) {
      shape.id = generateShapeId();  // 自动补充ID
    }
    shapeIdMap.set(shape.id, index);
  });
}

function findShapeById(id) {
  const index = shapeIdMap.get(id);
  return index !== undefined ? config.shapes[index] : null;
}
```

#### 2. 派生形状创建

```javascript
function offsetShape(sourceIndex) {
  const sourceShape = config.shapes[sourceIndex];

  // 创建派生形状
  const newShape = {
    type: sourceShape.type,
    id: generateShapeId(),
    name: `${sourceShape.name}_扩大缩小`,

    // 派生关系
    base_shape_id: sourceShape.id,
    derive_type: 'offset',

    // 继承的属性（带标记）
    vertices: sourceShape.vertices,
    vertices_inherited: true,

    fillet: {
      ...JSON.parse(JSON.stringify(sourceShape.fillet)),
      inherited: true
    },

    // 独立属性
    zoom: sourceShape.zoom || 0,
    layer: [sourceShape.layer[0] + 1, sourceShape.layer[1]]
  };

  config.shapes.push(newShape);
  renderShapeCard(newShape, config.shapes.length - 1);
  updateShapeIdMap();
}
```

#### 3. 同步更新机制

```javascript
// 在updateJSONFromForm中调用
function syncDerivedShapes(baseShapeId, changedProperties) {
  config.shapes.forEach((shape, index) => {
    if (shape.base_shape_id === baseShapeId) {
      const baseShape = findShapeById(baseShapeId);
      if (!baseShape) return;

      // 同步vertices
      if (shape.vertices_inherited && changedProperties.includes('vertices')) {
        shape.vertices = baseShape.vertices;
      }

      // 同步fillet
      if (shape.fillet?.inherited && changedProperties.includes('fillet')) {
        shape.fillet = {
          ...JSON.parse(JSON.stringify(baseShape.fillet)),
          inherited: true  // 保留继承标记
        };
      }

      // 重新渲染该形状卡片
      const card = document.querySelector(`[data-shape-index="${index}"]`);
      if (card) {
        updateShapeCardValues(card, shape, index);
      }
    }
  });
}
```

#### 4. 用户修改检测

```javascript
function onUserEditFillet(shapeIndex, field, newValue) {
  const shape = config.shapes[shapeIndex];

  if (shape.fillet?.inherited) {
    // 弹出确认对话框
    const confirmed = confirm(
      '修改倒角参数将不再跟随原形状变化，确认修改？\n' +
      '（可以通过"恢复继承"按钮重新启用自动同步）'
    );

    if (confirmed) {
      shape.fillet.inherited = false;  // 标记为独立
      shape.fillet[field] = newValue;
    }
  } else {
    // 已经是独立状态，直接修改
    shape.fillet[field] = newValue;
  }

  updateJSONFromForm();
}
```

#### 5. 恢复继承功能

```javascript
function restoreInheritance(shapeIndex, propertyName) {
  const shape = config.shapes[shapeIndex];
  const baseShape = findShapeById(shape.base_shape_id);

  if (!baseShape) {
    showAlert('找不到基础形状，无法恢复继承', 'danger');
    return;
  }

  if (propertyName === 'fillet') {
    shape.fillet = {
      ...JSON.parse(JSON.stringify(baseShape.fillet)),
      inherited: true
    };
  } else if (propertyName === 'vertices') {
    shape.vertices = baseShape.vertices;
    shape.vertices_inherited = true;
  }

  // 重新渲染
  refreshShapeCard(shapeIndex);
  updateJSONFromForm();
  showAlert('已恢复继承关系', 'success');
}
```

### UI改进

```html
<!-- 倒角参数输入框 -->
<div class="row">
  <div class="col-md-6 mb-3">
    <label class="form-label">
      倒角半径
      <span class="badge bg-success"
            v-if="shape.fillet?.inherited"
            title="当前继承自基础形状">
        继承中
      </span>
      <span class="badge bg-warning"
            v-else-if="shape.base_shape_id"
            title="已手动修改，不再跟随基础形状">
        已覆盖
      </span>
    </label>
    <div class="input-group">
      <input type="number"
             class="form-control"
             :value="shape.fillet.radius"
             @change="onUserEditFillet(index, 'radius', $event.target.value)">

      <!-- 恢复继承按钮 -->
      <button class="btn btn-outline-secondary"
              v-if="shape.base_shape_id && !shape.fillet?.inherited"
              @click="restoreInheritance(index, 'fillet')"
              title="恢复继承，重新跟随基础形状">
        <i class="bi bi-arrow-repeat"></i> 恢复继承
      </button>
    </div>
  </div>
</div>
```

### 优缺点分析

#### 优点
✅ **实现简单**
- 只需添加3个字段：`id`、`base_shape_id`、`inherited`标记
- 核心代码约200行，2-3天即可完成

✅ **改动最小**
- 不影响现有的表单处理逻辑
- 不需要重构数据流

✅ **易于调试**
- 继承关系清晰可见
- 标记位直观易懂

✅ **性能开销小**
- 同步操作是O(n)复杂度，n为派生形状数量
- 无需复杂的依赖追踪

#### 缺点
❌ **功能有限**
- 只支持整体属性继承，不支持部分继承
  - 例如：无法实现"只继承倒角类型，不继承半径"

❌ **缺少历史记录**
- 无法追溯"何时"、"谁"修改了参数
- 难以实现"撤销"功能

❌ **状态可能不一致**
- 标记位可能被意外修改
- 没有校验机制保证inherited标记的正确性

❌ **扩展性受限**
- 每增加一个继承属性，都要加对应的标记位
- 代码会变得重复

### 适用场景
- ✅ 项目初期，快速验证需求
- ✅ 形状数量较少（<30个）
- ✅ 继承关系简单（单层依赖）
- ❌ 需要复杂的继承控制
- ❌ 需要完整的变更审计

---

## 方案B：属性覆盖系统

### 设计理念

借鉴**CSS继承和覆盖机制**，实现完整的属性层级系统，支持精细化的属性级别控制。

### 数据结构设计

```yaml
# 原始形状
shapes:
  - type: polygon
    name: 基础多边形
    id: shape_abc123
    vertices: "0,0:10,0:10,10:0,10"
    fillet:
      type: arc
      radius: 5
    zoom: 0

  - type: polygon
    name: 基础多边形_扩大
    id: shape_def456

    # 派生关系配置块
    derivation:
      base_shape_id: shape_abc123
      derive_type: offset
      derive_params:
        zoom: 2
      created_at: "2025-01-14T10:30:00Z"

      # 属性覆盖映射表（核心机制）
      overrides:
        "fillet.type":
          value: "arc"
          overridden: true
          overridden_at: "2025-01-14T11:00:00Z"
          reason: "user_manual_edit"  # 覆盖原因

        "fillet.radius":
          value: null  # null = 使用继承值
          overridden: false

        "vertices":
          value: null
          overridden: false

    # 独立属性
    layer: [2, 0]

    # 运行时计算属性（不保存到YAML）
    _computed:
      vertices: "0,0:10,0:10,10:0,10"
      fillet: { type: "arc", radius: 5 }
      zoom: 2
```

### 核心机制

#### 1. 属性路径系统

```javascript
// 支持的属性路径列表
const INHERITABLE_PROPERTIES = [
  'vertices',
  'fillet.type',
  'fillet.radius',
  'fillet.radii',
  'fillet.precision',
  'fillet.convex_radius',
  'fillet.concave_radius',
  'zoom',
  '_metadata'  // 圆形元数据也可以继承
];

// 嵌套属性获取/设置工具
function getNestedProperty(obj, path) {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

function setNestedProperty(obj, path, value) {
  const keys = path.split('.');
  const lastKey = keys.pop();
  const target = keys.reduce((current, key) => {
    if (!current[key]) current[key] = {};
    return current[key];
  }, obj);
  target[lastKey] = value;
}
```

#### 2. 属性解析引擎

```javascript
function resolveShapeProperties(shape) {
  // 非派生形状，直接返回
  if (!shape.derivation) {
    return shape;
  }

  const baseShape = findShapeById(shape.derivation.base_shape_id);
  if (!baseShape) {
    console.error(`Base shape not found: ${shape.derivation.base_shape_id}`);
    return shape;
  }

  // 解析所有可继承属性
  const computed = {};

  INHERITABLE_PROPERTIES.forEach(propPath => {
    const override = shape.derivation.overrides?.[propPath];

    if (override?.overridden) {
      // 使用覆盖值
      setNestedProperty(computed, propPath, override.value);
    } else {
      // 使用继承值
      const inheritedValue = getNestedProperty(baseShape, propPath);
      setNestedProperty(computed, propPath, inheritedValue);
    }
  });

  // 应用派生参数
  if (shape.derivation.derive_params) {
    Object.assign(computed, shape.derivation.derive_params);
  }

  return {
    ...shape,
    _computed: computed
  };
}

// 批量解析所有形状
function resolveAllShapes() {
  return config.shapes.map(resolveShapeProperties);
}
```

#### 3. 变更检测与记录

```javascript
function onUserEditProperty(shapeIndex, propertyPath, newValue) {
  const shape = config.shapes[shapeIndex];

  // 非派生形状，直接设置
  if (!shape.derivation) {
    setNestedProperty(shape, propertyPath, newValue);
    updateJSONFromForm();
    return;
  }

  // 派生形状：创建或更新覆盖记录
  const baseShape = findShapeById(shape.derivation.base_shape_id);
  const inheritedValue = getNestedProperty(baseShape, propertyPath);

  // 初始化overrides对象
  if (!shape.derivation.overrides) {
    shape.derivation.overrides = {};
  }

  // 检查新值是否与继承值不同
  if (!deepEqual(newValue, inheritedValue)) {
    // 创建覆盖记录
    shape.derivation.overrides[propertyPath] = {
      value: newValue,
      overridden: true,
      overridden_at: new Date().toISOString(),
      reason: 'user_manual_edit',
      previous_inherited_value: inheritedValue  // 记录之前的继承值
    };

    showAlert(`属性 ${propertyPath} 已覆盖，不再跟随基础形状`, 'info');
  } else {
    // 新值与继承值相同，移除覆盖（恢复继承）
    if (shape.derivation.overrides[propertyPath]) {
      delete shape.derivation.overrides[propertyPath];
      showAlert(`属性 ${propertyPath} 已恢复继承`, 'success');
    }
  }

  // 重新计算属性
  const resolved = resolveShapeProperties(shape);
  updateShapeCardDisplay(shapeIndex, resolved);
  updateJSONFromForm();
}

// 深度相等比较
function deepEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (typeof a !== 'object' || typeof b !== 'object') return false;

  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;

  return keysA.every(key => deepEqual(a[key], b[key]));
}
```

#### 4. 智能同步系统

```javascript
function syncDerivedShapes(baseShapeId, changedProperties) {
  const affectedShapes = config.shapes
    .map((shape, index) => ({ shape, index }))
    .filter(({ shape }) => shape.derivation?.base_shape_id === baseShapeId);

  if (affectedShapes.length === 0) return;

  console.log(`同步 ${affectedShapes.length} 个派生形状，变更属性:`, changedProperties);

  affectedShapes.forEach(({ shape, index }) => {
    let needsUpdate = false;

    changedProperties.forEach(propPath => {
      const override = shape.derivation.overrides?.[propPath];

      // 只更新未被覆盖的属性
      if (!override?.overridden) {
        needsUpdate = true;
        console.log(`  - 形状 ${shape.name}: 同步属性 ${propPath}`);
      } else {
        console.log(`  - 形状 ${shape.name}: 跳过属性 ${propPath} (已覆盖)`);
      }
    });

    if (needsUpdate) {
      // 重新解析并更新UI
      const resolved = resolveShapeProperties(shape);
      updateShapeCardDisplay(index, resolved);
    }
  });

  updateJSONFromForm();
}

// 监听基础形状变化
const originalUpdateJSONFromForm = updateJSONFromForm;
updateJSONFromForm = function() {
  // 记录变化前的状态
  const oldShapes = JSON.parse(JSON.stringify(config.shapes));

  // 执行原有更新逻辑
  originalUpdateJSONFromForm.call(this);

  // 检测变化并触发同步
  config.shapes.forEach((newShape, index) => {
    const oldShape = oldShapes[index];
    if (!oldShape || !newShape.id) return;

    const changedProps = detectPropertyChanges(oldShape, newShape);
    if (changedProps.length > 0) {
      // 异步执行同步，避免阻塞UI
      setTimeout(() => {
        syncDerivedShapes(newShape.id, changedProps);
      }, 0);
    }
  });
};

function detectPropertyChanges(oldShape, newShape) {
  const changes = [];

  INHERITABLE_PROPERTIES.forEach(propPath => {
    const oldValue = getNestedProperty(oldShape, propPath);
    const newValue = getNestedProperty(newShape, propPath);

    if (!deepEqual(oldValue, newValue)) {
      changes.push(propPath);
    }
  });

  return changes;
}
```

#### 5. 恢复继承功能（增强版）

```javascript
function restoreInheritance(shapeIndex, propertyPath) {
  const shape = config.shapes[shapeIndex];

  if (!shape.derivation?.overrides?.[propertyPath]) {
    showAlert('该属性未被覆盖，无需恢复', 'info');
    return;
  }

  const override = shape.derivation.overrides[propertyPath];

  // 显示恢复确认对话框（含变更预览）
  const baseShape = findShapeById(shape.derivation.base_shape_id);
  const inheritedValue = getNestedProperty(baseShape, propertyPath);

  const confirmed = confirm(
    `确认恢复继承？\n\n` +
    `当前值: ${JSON.stringify(override.value)}\n` +
    `将变为: ${JSON.stringify(inheritedValue)}\n\n` +
    `恢复后，该属性将跟随基础形状自动更新。`
  );

  if (!confirmed) return;

  // 记录恢复操作（用于撤销）
  const restoreRecord = {
    shapeIndex,
    propertyPath,
    restoredAt: new Date().toISOString(),
    previousOverride: { ...override }
  };

  // 删除覆盖记录
  delete shape.derivation.overrides[propertyPath];

  // 重新解析并更新
  const resolved = resolveShapeProperties(shape);
  updateShapeCardDisplay(shapeIndex, resolved);
  updateJSONFromForm();

  showAlert(
    `属性 ${propertyPath} 已恢复继承\n` +
    `新值: ${JSON.stringify(inheritedValue)}`,
    'success'
  );

  // 保存恢复记录到撤销栈
  pushUndoStack(restoreRecord);
}
```

### UI增强

```html
<!-- 属性字段模板 -->
<div class="property-field" :class="getPropertyClass(shape, propPath)">
  <label class="form-label">
    {{ propertyLabel }}

    <!-- 继承状态徽章 -->
    <span v-if="isInherited(shape, propPath)"
          class="badge bg-success"
          title="继承自基础形状，自动同步">
      <i class="bi bi-link"></i> 继承中
    </span>

    <span v-else-if="isOverridden(shape, propPath)"
          class="badge bg-warning"
          title="已手动覆盖，不再同步">
      <i class="bi bi-pencil-fill"></i> 已覆盖
    </span>

    <!-- 覆盖信息提示 -->
    <span v-if="isOverridden(shape, propPath)"
          class="text-muted small"
          :title="getOverrideInfo(shape, propPath)">
      <i class="bi bi-info-circle"></i>
    </span>
  </label>

  <div class="input-group">
    <!-- 输入框 -->
    <input type="text"
           class="form-control"
           :value="getPropertyValue(shape, propPath)"
           @change="onUserEditProperty(shapeIndex, propPath, $event.target.value)"
           :class="{ 'text-primary': isInherited(shape, propPath) }">

    <!-- 恢复继承按钮 -->
    <button v-if="isOverridden(shape, propPath)"
            class="btn btn-outline-secondary"
            @click="restoreInheritance(shapeIndex, propPath)"
            title="恢复继承，重新跟随基础形状">
      <i class="bi bi-arrow-counterclockwise"></i>
    </button>

    <!-- 查看差异按钮 -->
    <button v-if="isOverridden(shape, propPath)"
            class="btn btn-outline-info"
            @click="showPropertyDiff(shapeIndex, propPath)"
            title="查看当前值与继承值的差异">
      <i class="bi bi-file-diff"></i>
    </button>
  </div>

  <!-- 继承值预览 -->
  <small v-if="isOverridden(shape, propPath)" class="form-text text-muted">
    继承值: {{ getInheritedValue(shape, propPath) }}
  </small>
</div>
```

```javascript
// UI辅助函数
function isInherited(shape, propPath) {
  if (!shape.derivation) return false;
  const override = shape.derivation.overrides?.[propPath];
  return !override?.overridden;
}

function isOverridden(shape, propPath) {
  return shape.derivation?.overrides?.[propPath]?.overridden === true;
}

function getOverrideInfo(shape, propPath) {
  const override = shape.derivation.overrides[propPath];
  if (!override) return '';

  return `覆盖时间: ${new Date(override.overridden_at).toLocaleString()}\n` +
         `原因: ${override.reason}\n` +
         `原继承值: ${JSON.stringify(override.previous_inherited_value)}`;
}

function showPropertyDiff(shapeIndex, propPath) {
  const shape = config.shapes[shapeIndex];
  const override = shape.derivation.overrides[propPath];
  const baseShape = findShapeById(shape.derivation.base_shape_id);
  const inheritedValue = getNestedProperty(baseShape, propPath);

  // 显示差异对比对话框
  const modal = createDiffModal({
    title: `属性差异: ${propPath}`,
    current: override.value,
    inherited: inheritedValue,
    overrideInfo: override
  });

  modal.show();
}
```

### 优缺点分析

#### 优点
✅ **功能强大**
- 支持属性级别的精细控制
- 可以实现"部分继承"（如只继承类型，不继承半径）

✅ **可追溯性**
- 完整的变更历史记录
- 知道"何时"、"为何"覆盖
- 便于实现撤销/重做功能

✅ **状态一致性**
- 覆盖记录与实际状态强关联
- 有校验机制保证数据完整性

✅ **扩展性好**
- 添加新的继承属性只需修改 `INHERITABLE_PROPERTIES` 列表
- 代码高度模块化，易于维护

✅ **用户体验优秀**
- 差异对比功能
- 详细的覆盖信息提示
- 可视化的继承状态

#### 缺点
❌ **实现复杂**
- 需要实现完整的属性路径系统
- 需要重构表单处理逻辑
- 开发工作量约1-2周

❌ **配置文件变大**
- overrides对象会增加YAML文件大小
- 需要优化序列化/反序列化性能

❌ **学习曲线陡**
- 开发者需要理解属性路径和覆盖机制
- 调试复杂度增加

❌ **性能开销较大**
- 每次更新都要遍历所有属性路径
- 需要实现缓存和优化机制

### 适用场景
- ✅ 需要精细化继承控制
- ✅ 需要完整的变更审计
- ✅ 形状数量较多（>30个）
- ✅ 复杂的依赖关系
- ❌ 项目时间紧迫
- ❌ 团队经验不足

---

## 方案对比总结

| 维度 | 方案A（轻量级） | 方案B（健壮型） |
|------|----------------|----------------|
| **实施难度** | ⭐⭐ 低 | ⭐⭐⭐⭐⭐ 高 |
| **开发时间** | 2-3天 | 1-2周 |
| **代码改动量** | ~200行 | ~800行 |
| **配置文件增量** | +10% | +30% |
| **扩展性** | ⭐⭐ 有限 | ⭐⭐⭐⭐⭐ 优秀 |
| **维护成本** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ 较高 |
| **用户体验** | ⭐⭐⭐ 基本满足 | ⭐⭐⭐⭐⭐ 优秀 |
| **性能开销** | ⭐ 极小 | ⭐⭐⭐ 中等 |
| **风险控制** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 优秀 |
| **可追溯性** | ⭐⭐ 弱 | ⭐⭐⭐⭐⭐ 强 |
| **精细控制** | ⭐⭐ 整体继承 | ⭐⭐⭐⭐⭐ 属性级 |

---

## 推荐策略

### 渐进式实施路线

**阶段1：基础MVP（方案A）**
- 时间：1周
- 目标：快速验证核心概念
- 功能：
  - 基础ID系统
  - 简单的继承标记
  - vertices和fillet的整体继承
  - 基本的UI指示

**阶段2：功能增强（方案A+）**
- 时间：1周
- 目标：完善用户体验
- 功能：
  - 循环依赖检测
  - 删除保护
  - 恢复继承功能
  - 依赖关系显示

**阶段3：高级特性（过渡到方案B）**
- 时间：2周
- 目标：支持复杂场景
- 功能：
  - 引入属性路径系统
  - 逐步迁移到overrides机制
  - 保持向后兼容
  - 性能优化

**阶段4：完全体（方案B）**
- 时间：1周
- 目标：达到生产级质量
- 功能：
  - 完整的变更审计
  - 差异对比
  - 撤销/重做
  - 批量操作

### 技术债务管理

**方案A的技术债**：
- 缺少变更历史
- 扩展性受限
- 状态一致性保证弱

**迁移策略**：
```javascript
// 数据格式自动升级
function migrateToOverridesSystem(shape) {
  if (shape.fillet?.inherited !== undefined) {
    // 旧格式：inherited标记
    const inherited = shape.fillet.inherited;
    delete shape.fillet.inherited;

    // 转换为新格式：overrides系统
    shape.derivation = {
      ...shape.derivation,
      overrides: {
        'fillet.type': {
          value: shape.fillet.type,
          overridden: !inherited
        },
        'fillet.radius': {
          value: shape.fillet.radius,
          overridden: !inherited
        }
      }
    };
  }

  return shape;
}
```

---

## 决策建议

### 如果选择方案A
**适合场景**：
- 项目处于早期阶段
- 需要快速验证产品方向
- 团队对复杂系统经验不足
- 形状数量和依赖关系相对简单

**注意事项**：
- 预留未来升级的接口
- 严格测试边界情况
- 及时记录技术债务

### 如果选择方案B
**适合场景**：
- 产品已进入成熟期
- 有明确的复杂需求
- 团队技术实力强
- 追求长期可维护性

**注意事项**：
- 分阶段实施，降低风险
- 提供详细文档
- 做好性能优化

### 如果选择混合方案
**推荐做法**：
1. 先用方案A快速上线（1-2周）
2. 收集用户反馈，验证需求
3. 根据实际使用情况决定是否升级
4. 如需升级，逐步迁移到方案B（2-3周）

**优势**：
- 最小化风险
- 快速获得用户反馈
- 为未来扩展预留空间
- 技术债可控

---

**文档版本**：v1.0
**创建时间**：2025-01-14
**作者**：Claude + User
**状态**：待审核
